[
["index.html", "Variable selection in microbiome compositional data analysis: tutorial Chapter 1 Introduction 1.1 Packages installation and loading 1.2 Example datasets", " Variable selection in microbiome compositional data analysis: tutorial Antoni Susin, Yiwen Wang, Kim-Anh Lê Cao, M.Luz Calle 2019-09-25 Chapter 1 Introduction This vignette provides a comparison of three multivariate methods for microbiome variable selection that consider the compositional structure of microbiome data: CoDA-lasso: penalized regression with constraint coefficients (regression coefficients sum up to zero) (Lu, Shi, and Li 2019; Lin et al. 2014); CLR-lasso: penalized regression after the centered log-ratio (CLR) transformation (Zou and Hastie 2005; Tibshirani 1996; Le Cessie and Van Houwelingen 1992); selbal: forward selection to identify the balance between two groups of taxa that is more associated with the response variable (Rivera-Pinto et al. 2018). 1.1 Packages installation and loading Install then load the following packages: # cran.packages &lt;- c(&#39;knitr&#39;, &#39;glmnet&#39;, &#39;ggplot2&#39;, &#39;gridExtra&#39;, # &#39;UpSetR&#39;, &#39;ggforce&#39;, &#39;pROC&#39;) # install.packages(cran.packages) # devtools::install_github(repo = &#39;UVic-omics/selbal&#39;) library(knitr) # rbookdown, kable library(glmnet) # glmnet library(selbal) # selbal library(ggplot2) # draw selbal library(gridExtra) # grid.arrange library(UpSetR) # upset library(ggforce) # selbal-like plot library(pROC) # ROC curve # build in functions source(file = &#39;functions.R&#39;) 1.2 Example datasets 1.2.1 Crohn’s disease Crohn’s disease (CD) is an inflammatory bowel disease that has been linked to microbial alterations in the gut (Gevers et al. 2014; Øyri, Műzes, and Sipos 2015). We used data from a large pediatric CD cohort study (Gevers et al. 2014) to compare the proposed methodologies for identification of microbial signatures. The microbiome data were generated using 16S rRNA gene sequencing with QIIME 1.7.0 bioinformatics processing, and the processed data were downloaded from Qiita (Rivera-Pinto et al. 2018). Only patients with Crohn’s disease (n = 662) and those without any symptoms (n = 313) were analyzed. The OTU table was agglomerated to the genus level, resulting in a matrix with 48 genera and 975 samples (see Table 1.1). Load the data as follows: load(&#39;./datasets/CD_data.RData&#39;) 1.2.2 High fat high sugar diet in mice The study was conducted by Dr Lê Cao at the University of Queensland Diamantina Institute that investigated the effect of diet in mice. C57/B6 female black mice were housed in cages (3 animals per cage and fed with a high fat high sugar diet (HFHS) or a normal diet). Stool sampling was performed at Day 0, 1, 4 and 7. Illumina MiSeq sequencing was used to obtain the 16S rRNA sequencing data. The sequencing data were then processed with QIIME 1.9.0. For our analysis, we considered Day 1 only (HFHS-Day1). The OTU (Operational Taxonomy Units) table after OTU filtering included 558 taxa and 47 samples (24 HFHS diet and 23 normal diet) (see Table 1.1). Taxonomy information from Family, Genus, and Species are also available and reported here. load(&#39;./datasets/HFHS_data.RData&#39;) Table 1.1: Summary of case studies CD data HFHS-Day1 data No. of genera 48 No. of OTUs 558 No. of samples 975 No. of samples 47 No. of patients with CD 662 No. of mice with HFHS diet 24 No. of healthy patients 313 No. of mice with normal diet 23 References "],
["coda.html", "Chapter 2 CoDA-lasso 2.1 CD data 2.2 HFHS-Day1 data", " Chapter 2 CoDA-lasso First, we illustrate the method CoDA-lasso, which is the penalized regression with constraint coefficients (regression coefficients sum up to zero) (Lu, Shi, and Li 2019; Lin et al. 2014) in compositional data analysis (CoDA). This method was implemented in the function coda_lasso(), which was adapted from matlab. In this chapter, we are going to use function rangLambda2() and coda_lasso(). Both of them have been loaded through file functions.R. 2.1 CD data In CD data, the matrix of microbial absolute abundances (counts) are treated as input X. CD data have 975 samples and 48 taxa (genera). The rows of X are individuals/samples, the columns are taxa. dim(CD.x) ## [1] 975 48 For CoDA-lasso, X can either be absolute abundances or relative abundances (proportions). However, X should not be the matrix of log(counts) or log(proportions), because the method itself performs the log-transformation of the abundances. Y is a binary outcome, coded as a factor with two levels (CD vs. non-CD). class(CD.y) ## [1] &quot;factor&quot; summary(CD.y) ## CD no ## 662 313 To run the method, we need a value of \\(\\lambda\\). \\(\\lambda\\) is the penalization parameter: the larger the value of \\(\\lambda\\), the fewer number of variables will be selected. The default initial \\(\\lambda\\) is lambdaIni = 1. When \\(\\lambda = 1\\), there is no microbial variable will be selected. rangLambda2(Y = CD.y, X = CD.x, numLambda = 12, lambdaIni = 0.2) ## $call ## rangLambda2(Y = CD.y, X = CD.x, numLambda = 12, lambdaIni = 0.2) ## ## $ranglambdas ## lambda numVarSelect ## [1,] 0.20000000 8 ## [2,] 0.18181818 11 ## [3,] 0.16363636 20 ## [4,] 0.14545455 20 ## [5,] 0.12727273 16 ## [6,] 0.10909091 29 ## [7,] 0.09090909 20 ## [8,] 0.07272727 23 ## [9,] 0.05454545 26 ## [10,] 0.03636364 31 ## [11,] 0.01818182 41 ## [12,] 0.00000000 48 It provides a range of \\(\\lambda\\) values (lambda) and corresponding number of microbial variables selected (numVarSelect) according to a given number of \\(\\lambda\\)s (numLambda). CD.results_codalasso &lt;- coda_lasso(Y = CD.y, X = CD.x, lambda = 0.19) CD.results_codalasso$numVarSelect ## [1] 11 CD.results_codalasso$varSelect ## [1] &quot;g__Roseburia&quot; &quot;g__Dialister&quot; ## [3] &quot;g__Streptococcus&quot; &quot;g__Aggregatibacter&quot; ## [5] &quot;f__Peptostreptococcaceae_g__&quot; &quot;g__Eggerthella&quot; ## [7] &quot;o__Lactobacillales_g__&quot; &quot;g__Lachnospira&quot; ## [9] &quot;g__Parabacteroides&quot; &quot;g__Prevotella&quot; ## [11] &quot;g__Bilophila&quot; The method selects 11 genera with \\(\\lambda = 0.19\\). 2.2 HFHS-Day1 data The analysis on HFHS-Day1 data is similar as CD data. dim(HFHS.x) ## [1] 47 558 class(HFHS.y) ## [1] &quot;factor&quot; summary(HFHS.y) ## HFHS Normal ## 24 23 In HFHS-Day1 data, Y is also a factor with two levels (HFHS vs. Normal) We then test a range of \\(\\lambda\\) and estimate the number of selected OTUs for each \\(\\lambda\\). rangLambda2(Y = HFHS.y, X = HFHS.x, numLambda = 20, lambdaIni = 0.3) ## $call ## rangLambda2(Y = HFHS.y, X = HFHS.x, numLambda = 20, lambdaIni = 0.3) ## ## $ranglambdas ## lambda numVarSelect ## [1,] 0.30000000 2 ## [2,] 0.28421053 2 ## [3,] 0.26842105 2 ## [4,] 0.25263158 2 ## [5,] 0.23684211 35 ## [6,] 0.22105263 2 ## [7,] 0.20526316 2 ## [8,] 0.18947368 11 ## [9,] 0.17368421 2 ## [10,] 0.15789474 33 ## [11,] 0.14210526 7 ## [12,] 0.12631579 10 ## [13,] 0.11052632 2 ## [14,] 0.09473684 50 ## [15,] 0.07894737 5 ## [16,] 0.06315789 17 ## [17,] 0.04736842 20 ## [18,] 0.03157895 230 ## [19,] 0.01578947 106 ## [20,] 0.00000000 558 We specify a \\(\\lambda\\) and run the CoDA-lasso. HFHS.results_codalasso &lt;- coda_lasso(Y = HFHS.y, X = HFHS.x, lambda = 0.18) HFHS.results_codalasso$numVarSelect ## [1] 11 HFHS.results_codalasso$varSelect ## [1] &quot;192222&quot; &quot;401384&quot; &quot;263479&quot; &quot;348038&quot; &quot;400599&quot; &quot;1105860&quot; &quot;4379961&quot; ## [8] &quot;338796&quot; &quot;407963&quot; &quot;462764&quot; &quot;175272&quot; The method selects 11 OTUs with \\(\\lambda = 0.18\\). We also extract the taxonomic information of these selected OTUs. HFHS.tax_codalasso &lt;- HFHS.taxonomy[which(rownames(HFHS.taxonomy) %in% HFHS.results_codalasso$varSelect), ] kable(HFHS.tax_codalasso[ ,2:6], booktabs = T) Phylum Class Order Family Genus 192222 Bacteroidetes Bacteroidia Bacteroidales Prevotellaceae 1105860 Firmicutes Erysipelotrichi Erysipelotrichales Erysipelotrichaceae Allobaculum 4379961 Firmicutes Erysipelotrichi Erysipelotrichales Erysipelotrichaceae Allobaculum 338796 Firmicutes Clostridia Clostridiales Ruminococcaceae Oscillospira 462764 Firmicutes Clostridia Clostridiales Ruminococcaceae Ruminococcus 263479 Bacteroidetes Bacteroidia Bacteroidales S24-7 400599 Firmicutes Clostridia Clostridiales 407963 Firmicutes Clostridia Clostridiales Ruminococcaceae Oscillospira 348038 Bacteroidetes Bacteroidia Bacteroidales S24-7 401384 Firmicutes Clostridia Clostridiales Ruminococcaceae Oscillospira 175272 Bacteroidetes Bacteroidia Bacteroidales S24-7 References "],
["clr.html", "Chapter 3 CLR-lasso 3.1 CD data 3.2 HFHS-Day1 data", " Chapter 3 CLR-lasso Then, we illustrate CLR-lasso, which is the penalized regression after the centered log-ratio (CLR) transformation (Zou and Hastie 2005; Tibshirani 1996; Le Cessie and Van Houwelingen 1992). This method was applied based on function glmnet(). We also generated a wrapper function called glmnet_wrapper(). It is based on glmnet(), but provides additional outputs. All these functions are uploaded via functions.R. 3.1 CD data As mentioned in the paper, CLR transformation is each log-transformed value subtracted with the arithmetic mean of the log-transformed values. \\[clr(x) = clr(x_{1},...,x_{k}) = (log(x_{1})-M,...,log(x_{k})-M)\\] \\[M = \\frac{1}{k}\\sum_{i=1}^{k}log(x_{i})\\] Where \\(i=1,...,k\\) microbial variables, \\(x_{k}\\) is the counts of variable \\(k\\), \\(M\\) is the arithmetic mean of the log-transformed values. # CLR transformation CD.z &lt;- log(CD.x) CD.clrx &lt;- apply(CD.z, 2, function(x) x - rowMeans(CD.z)) CD.y.num &lt;- as.numeric(CD.y) Here, Y is converted to be numeric, because glmnet() requires Y to be numeric. Same as CoDA-lasso, we first need to choose a \\(\\lambda\\). We fit CLR transformed X and numeric Y as input of function glmnet(). We also need to specify the response family to be binomial. CD.test_clrlasso &lt;- glmnet(x = CD.clrx, y = CD.y.num, family = &#39;binomial&#39;) plot(CD.test_clrlasso, xvar = &#39;lambda&#39;, label = T) Figure 3.1: Lasso plot of CD data In Figure 3.1, each curve corresponds to a variable (e.g. genus). It shows the path of its coefficient against different \\(log(\\lambda)\\) values. At each \\(log(\\lambda)\\), the shown curves indicate the number of nonzero coefficients. In the plot command, if label = T, each curve will be annotated with variable index. Once we have chosen the \\(\\lambda\\) value, it is input in our new wrapper function glmnet_wrapper(). CD.lambda_clr = 0.045 CD.results_clrlasso &lt;- glmnet_wrapper(Y = CD.y.num, X = CD.clrx, family = &#39;binomial&#39;, lambda = CD.lambda_clr) CD.results_clrlasso$numVarSelect ## [1] 11 CD.results_clrlasso$varSelect ## [1] &quot;g__Roseburia&quot; &quot;g__Eggerthella&quot; ## [3] &quot;g__Bacteroides&quot; &quot;f__Peptostreptococcaceae_g__&quot; ## [5] &quot;g__Dialister&quot; &quot;g__Streptococcus&quot; ## [7] &quot;g__Adlercreutzia&quot; &quot;g__Aggregatibacter&quot; ## [9] &quot;o__Clostridiales_g__&quot; &quot;g__Lachnospira&quot; ## [11] &quot;o__Lactobacillales_g__&quot; The method selects 11 genera with \\(\\lambda = 0.045\\), and they are listed in the object CD.results_clrlasso. 3.2 HFHS-Day1 data The analysis on HFHS-Day1 data is as similar as CD data. # CLR transformation HFHS.z &lt;- log(HFHS.x) HFHS.clrx &lt;- apply(HFHS.z, 2, function(x) x-rowMeans(HFHS.z)) X is centered log-ratio (CLR) transformed. HFHS.y.num &lt;- as.numeric(HFHS.y) Y is converted to a numeric vector. HFHS.test_clrlasso &lt;- glmnet(x = HFHS.clrx, y = HFHS.y.num, family = &#39;binomial&#39;) plot(HFHS.test_clrlasso, xvar = &#39;lambda&#39;, label = T) Figure 3.2: Lasso plot of HFHS-Day1 data The explanation of Figure 3.2 is the same as Figure 3.1. Once we have chosen the \\(\\lambda\\) value, we use function glmnet_wrapper() with the same input as glmnet() and extra input \\(\\lambda\\). HFHS.lambda_clr = 0.03 HFHS.results_clrlasso &lt;- glmnet_wrapper(Y = HFHS.y.num, X = HFHS.clrx, family = &#39;binomial&#39;, lambda = HFHS.lambda_clr) HFHS.results_clrlasso$numVarSelect ## [1] 10 HFHS.results_clrlasso$varSelect ## [1] &quot;400599&quot; &quot;192222&quot; &quot;348038&quot; &quot;401384&quot; &quot;290253&quot; &quot;261265&quot; &quot;300851&quot; ## [8] &quot;462764&quot; &quot;1108745&quot; &quot;265322&quot; The method selects 10 OTUs with \\(\\lambda = 0.03\\), and these OTUs are listed in the object HFHS.results_clrlasso. We also extract the taxonomic information of these selected OTUs. HFHS.tax_clrlasso &lt;- HFHS.taxonomy[which(rownames(HFHS.taxonomy) %in% HFHS.results_clrlasso$varSelect), ] kable(HFHS.tax_clrlasso[ ,2:6], booktabs = T) Phylum Class Order Family Genus 192222 Bacteroidetes Bacteroidia Bacteroidales Prevotellaceae 290253 Firmicutes Clostridia Clostridiales Ruminococcaceae Oscillospira 261265 Firmicutes Clostridia Clostridiales Lachnospiraceae 1108745 Firmicutes Clostridia Clostridiales [Mogibacteriaceae] 462764 Firmicutes Clostridia Clostridiales Ruminococcaceae Ruminococcus 265322 Bacteroidetes Bacteroidia Bacteroidales S24-7 400599 Firmicutes Clostridia Clostridiales 348038 Bacteroidetes Bacteroidia Bacteroidales S24-7 401384 Firmicutes Clostridia Clostridiales Ruminococcaceae Oscillospira 300851 Firmicutes Clostridia Clostridiales Ruminococcaceae Oscillospira References "],
["selbal.html", "Chapter 4 Selbal: selection of balances 4.1 CD data 4.2 HFHS-Day1 data", " Chapter 4 Selbal: selection of balances selbal (Rivera-Pinto et al. 2018) relies on the concept of compositional balances, which is the balance between the abundances of two groups of microbial species that is more associated with the response variable. We also generated a wrapper function called selbal_wrapper(). It is based on selbal(), but provides additional outputs. All these functions are uploaded via functions.R. 4.1 CD data class(CD.y) ## [1] &quot;factor&quot; selbal() requires Y to be factor, as it will run logistic regression with a binary outcomes. If Y is numeric, selbal() implements linear regression. Besides input Y and X, we also need to decide how many variables to select (maxV). The default performance measure (logit.acc) to compute the correlation between Y and balances is AUC, other opitions can be “Dev”, “Rsq” or “Tjur”. # optimization criteria Deviance CD.results_selbal &lt;- selbal_wrapper(Y = CD.y, X = CD.x, maxV = 12, logit.acc = &#39;Dev&#39;) CD.results_selbal$numVarSelect ## [1] 12 CD.results_selbal$varSelect ## [1] &quot;g__Roseburia&quot; &quot;g__Eggerthella&quot; ## [3] &quot;g__Dialister&quot; &quot;g__Streptococcus&quot; ## [5] &quot;f__Peptostreptococcaceae_g__&quot; &quot;g__Bacteroides&quot; ## [7] &quot;g__Aggregatibacter&quot; &quot;g__Adlercreutzia&quot; ## [9] &quot;g__Dorea&quot; &quot;g__Oscillospira&quot; ## [11] &quot;o__Clostridiales_g__&quot; &quot;g__Blautia&quot; The method selects 12 genera as we required. 4.2 HFHS-Day1 data The analysis on HFHS-Day1 data is as similar as CD data. First, we need to check if Y is a factor. class(HFHS.y) ## [1] &quot;factor&quot; # optimization criteria Deviance HFHS.results_selbal &lt;- selbal_wrapper(Y = HFHS.y, X = HFHS.x, maxV = 2, logit.acc = &#39;Dev&#39;) HFHS.results_selbal$numVarSelect ## [1] 2 HFHS.results_selbal$varSelect ## [1] &quot;290253&quot; &quot;263479&quot; The method selects 2 OTUs as required. We also extract the taxonomic information of these selected OTUs. HFHS.tax_selbal &lt;- HFHS.taxonomy[which(rownames(HFHS.taxonomy) %in% HFHS.results_selbal$varSelect), ] kable(HFHS.tax_selbal[ ,2:6], booktabs = T) Phylum Class Order Family Genus 290253 Firmicutes Clostridia Clostridiales Ruminococcaceae Oscillospira 263479 Bacteroidetes Bacteroidia Bacteroidales S24-7 References "],
["comparison.html", "Chapter 5 Concordance of variables selected by the three methods 5.1 CD data 5.2 HFHS-Day1 data", " Chapter 5 Concordance of variables selected by the three methods In this chapter, we are going to use different visualisation approaches to display the variables selected by the three methods: UpSet plot: highlights overlap of the variables selected by the three methods. Selbal-like plot: lists the selected variables and displays their discriminating ability with respect to sample groups. plotLoadings: visualises the variable coefficients and sample groups each variable contributes to. Trajectory plot: represents the rank of the variables selected by CoDA-lasso and CLR-lasso, and their corresponding regression coefficients GraPhlAn: displays the taxonomic tree of selected variables (HFHS-Day1 data only). 5.1 CD data 5.1.1 UpSetR UpSet is a visualisation technique for the quantitative analysis of sets and their intersections (Lex et al. 2014). Before we apply upset(), we take the list of variable vectors selected with the three methods and convert them into a data frame compatible with upset() using fromList(). We then assign different color shcemes for each variable selection. CD.select &lt;- list(CoDA_lasso = CD.results_codalasso$varSelect, CLR_lasso = CD.results_clrlasso$varSelect, selbal = CD.results_selbal$varSelect) CD.select.upsetR &lt;- fromList(CD.select) upset(as.data.frame(CD.select.upsetR), main.bar.color = &#39;gray36&#39;, sets.bar.color = color[c(1:2,5)], matrix.color = &#39;gray36&#39;, order.by = &#39;freq&#39;, empty.intersections = &#39;on&#39;, queries = list(list(query = intersects, params = list(&#39;CoDA_lasso&#39;), color = color[5], active = T), list(query = intersects, params = list(&#39;CLR_lasso&#39;), color = color[2], active = T), list(query = intersects, params = list(&#39;selbal&#39;), color = color[1], active = T))) Figure 5.1: UpSet plot showing overlap between variables selected with different methods. In Figure 5.1, the left bars show the number of variables selected by each method. The right bar plot combined with the scatterplot show different intersection situations and their aggregates. For example, in the first column, three points are linked with one line, and the intersection size of the bar is 6. This means that 6 variables are selected by all these three methods. While in the second column, 3 variables are only selected by the method CoDA-lasso. 5.1.2 Selbal-like plot Selbal-like plot is an extension of the plot proposed by Rivera-Pinto et al. (2018). # CoDA_lasso CD.coda_pos &lt;- CD.results_codalasso$posCoefSelect CD.coda_neg &lt;- CD.results_codalasso$negCoefSelect selbal_like_plot(pos.names = names(CD.coda_pos), neg.names = names(CD.coda_neg), Y = CD.y, X = CD.x) Figure 5.2: Selbal-like plot showing variables selected with method CoDA-lasso and the ability of these variables to discriminate CD and non-CD individuals. In Figure 5.2, the top left panel lists the selected variable names with either negative or positive coefficients. The names are ordered according to their importance (absolute coefficient values). The top right panel is the Receiver Operating Characteristic (ROC) curve based on generalised linear model: \\(g(E(Y)) = \\beta_{0} + \\beta_{1}logX_{1}+...+\\beta_{p}logX_{p}\\) with \\(p\\) selected variables. The Area Under the Curve (AUC) is 0.822, which indicates the ability to discriminate the sample groups. The bottom left boxplot is based on the log mean difference between negative and positive variables: \\(\\frac{1}{p_{+}}\\sum_{i=1}^{p_{+}}logX_{i} - \\frac{1}{p_{-}}\\sum_{j=1}^{p_{-}}logX_{j}\\). This log mean difference is calculated for each sample as a balance score, because it is proportionally equal to the balance mentioned in (Rivera-Pinto et al. 2018). The bottom right density plots represent the distributions of the log mean difference scores for CD and non-CD individuals. # CLR_lasso CD.clr_pos &lt;- CD.results_clrlasso$posCoefSelect CD.clr_neg &lt;- CD.results_clrlasso$negCoefSelect selbal_like_plot(pos.names = names(CD.clr_pos), neg.names = names(CD.clr_neg), Y = CD.y, X = CD.x) Figure 5.3: Selbal-like plot showing variables selected with method CLR-lasso and the ability of these variables to discriminate CD and non-CD individuals. The interpretation of Figure 5.3 is the same as Figure 5.2, but with variables selected with method CLR-lasso. # selbal CD.selbal_pos &lt;- CD.results_selbal$posVarSelect CD.selbal_neg &lt;- CD.results_selbal$negVarSelect selbal_like_plot(pos.names = CD.selbal_pos, neg.names = CD.selbal_neg, Y = CD.y, selbal = TRUE, FINAL.BAL = CD.results_selbal$finalBal) Figure 5.4: Selbal plot showing variables selected with method selbal and the ability of these variables to discriminate CD and non-CD individuals. In Figure 5.4, for the selbal method, the two groups of variables that form the global balance are specified at the top of the plot. They are equally important. The box plot represents the distribution of the balance scores for CD and non-CD individuals. The right part of the figure contains the ROC curve (\\(g(E(Y)) = \\beta_{0} + \\beta_{1}B(Den,Num)\\)) with its AUC value (0.841, higher than other methods) and the density curve for each group. 5.1.3 plotLoadings As all these above plots do not visualise the coefficients of the selected variables, we then apply a modified plotLoadings (Rohart et al. 2017) to display the coefficients. # CoDA_lasso CD.coda_coef &lt;- CD.results_codalasso$coefficientsSelect CD.coda_data &lt;- CD.x[ ,CD.results_codalasso$varSelect] CD.coda.plotloadings &lt;- plotcoefficients(coef = CD.coda_coef, data = CD.coda_data, Y = CD.y, title = &#39;Coefficients of CoDA-lasso on CD data&#39;) Figure 5.5: The plotLoadings of selected variables with CoDA-lasso. Figure 5.5 shows that the taxa colored in orange are more abundant in non-CD samples relative to CD samples (e.g. Roseburia), while the blue ones are more abundant in CD samples relative to non-CD samples (e.g. Dialister). It is based on their mean per group (CD vs. non-CDs). The bar indicates the coefficient. As we can see, several taxa are more abundant in non-CD group, but with a negative coefficient. It means this model is not optimal at some extent. # CLR_lasso CD.clr_coef &lt;- CD.results_clrlasso$coefficientsSelect CD.clr_data &lt;- CD.x[ ,CD.results_clrlasso$varSelect] CD.clr.plotloadings &lt;- plotcoefficients(coef = CD.clr_coef, data = CD.clr_data, Y = CD.y, title = &#39;Coefficients of clr-lasso on CD data&#39;) Figure 5.6: The plotLoadings of selected variables with CLR-lasso. The interpretation of Figure 5.6 is the same as Figure 5.5. From Figure 5.6, all the selected variables that more abundant in non-CD samples are assigned with positive coefficients. It means CLR-lasso seems more optimal than CoDA-lasso. Both Roseburia and Peptostreptococcaceae are selected by CoDA-lasso and CLR-lasso that are more abundant in non-CD group. Although both Eggerthella and Dialister are also selected by two methods, but with very different coefficient rank. 5.1.4 Trajectory plots To visualise the change of variable coefficients and their ranks in the selection between different methods, we introduce trajectory plots. TRAJ_plot(selectVar_coef_method1 = CD.coda_coef, selectVar_coef_method2 = CD.clr_coef, selectMethods = c(&#39;CoDA-lasso&#39;, &#39;CLR-lasso&#39;)) Figure 5.7: Trajectory plots of selected variables from both CoDA-lasso and CLR-lasso in CD data. Figure 5.7 shows the selected variables ordered by their rank in the selection (according to their coefficient absolute values) between CoDA-lasso and CLR-lasso, with the thickness of the lines representing the coefficient absolute values. In this plot, it is easy to visualise the rank change of each selected variable between CoDA-lasso and CLR-lasso selection. For example, the rank of Dialister is lower in CLR-lasso compared to CoDA-lasso. Moreover, it is also easy to detect the variables (e.g. Bacteroides) that are selected by one method (e.g. CLR-lasso) with high coefficient rank, but not selected by the other method (e.g. CoDA-lasso). 5.2 HFHS-Day1 data 5.2.1 UpSetR HFHS.select &lt;- list(CoDA_lasso = HFHS.results_codalasso$varSelect, CLR_lasso = HFHS.results_clrlasso$varSelect, selbal = HFHS.results_selbal$varSelect) HFHS.select.upsetR &lt;- fromList(HFHS.select) upset(as.data.frame(HFHS.select.upsetR), main.bar.color = &#39;gray36&#39;, sets.bar.color = color[c(5,2,1)], matrix.color = &#39;gray36&#39;, order.by = &#39;freq&#39;, empty.intersections = &#39;on&#39;, queries = list(list(query = intersects, params = list(&#39;CoDA_lasso&#39;), color = color[5], active = T), list(query = intersects, params = list(&#39;CLR_lasso&#39;), color = color[2], active = T), list(query = intersects, params = list(&#39;selbal&#39;), color = color[1], active = T))) Figure 5.8: UpSet plot showing overlap between variables selected with different methods. Figure 5.8 shows that 5 OTUs are only selected with CoDA-lasso, 5 OTUs are selected both with CoDA-lasso and CLR-lasso, 4 OTUs are only selected with CLR-lasso, 1 OTUs is selected with both CLR-lasso and selbal, and 1 is selected both with CoDA-lasso and selbal. Among three methods, CoDA-lasso selected the most OTUs and selbal the least. 5.2.2 Selbal-like plot # CoDA_lasso HFHS.coda_pos &lt;- HFHS.results_codalasso$posCoefSelect HFHS.coda_neg &lt;- HFHS.results_codalasso$negCoefSelect selbal_like_plot(pos.names = names(HFHS.coda_pos), neg.names = names(HFHS.coda_neg), Y = HFHS.y, X = HFHS.x, OTU = T, taxa = HFHS.taxonomy) Figure 5.9: Selbal-like plot showing variables selected with method CoDA-lasso and the ability of these variables to discriminate HFHS and normal individuals. Note: S24-7 is a family from order Bacteroidales. # CLR_lasso HFHS.clr_pos &lt;- HFHS.results_clrlasso$posCoefSelect HFHS.clr_neg &lt;- HFHS.results_clrlasso$negCoefSelect selbal_like_plot(pos.names = names(HFHS.clr_pos), neg.names = names(HFHS.clr_neg), Y = HFHS.y, X = HFHS.x, OTU = T, taxa = HFHS.taxonomy) Figure 5.10: Selbal-like plot showing variables selected with method CLR-lasso and the ability of these variables to discriminate HFHS and normal individuals. # selbal HFHS.selbal_pos &lt;- HFHS.results_selbal$posVarSelect HFHS.selbal_neg &lt;- HFHS.results_selbal$negVarSelect selbal_like_plot(pos.names = HFHS.selbal_pos, neg.names = HFHS.selbal_neg, Y = HFHS.y, selbal = TRUE, FINAL.BAL = HFHS.results_selbal$finalBal, OTU = T, taxa = HFHS.taxonomy) Figure 5.11: Selbal plot showing variables selected with methd selbal and the ability of these variables to discriminate HFHS and normal individuals. These plots show that the variables selected from three different methods all have a maximum discrimination (AUC = 1) between HFHS samples and normal ones. Among these methods, selbal only needs two OTUs to build a balance, it also means the association between microbiome composition and diet is very strong. 5.2.3 plotLoadings # CoDA_lasso HFHS.coda_coef &lt;- HFHS.results_codalasso$coefficientsSelect HFHS.coda_data &lt;- HFHS.x[ ,HFHS.results_codalasso$varSelect] HFHS.coda.plotloadings &lt;- plotcoefficients(coef = HFHS.coda_coef, data = HFHS.coda_data, Y = HFHS.y, title = &#39;Coefficients of CoDA-lasso on HFHS-Day1 data&#39;, OTU = T, taxa = HFHS.taxonomy) Figure 5.12: The plotLoadings of selected variables with CoDA-lasso. In Figure 5.12, two OTUs 1105860: Allobaculum and 175272: S24-7 are more abundant in HFHS group but are assigned with positive coefficients. # CLR_lasso HFHS.clr_coef &lt;- HFHS.results_clrlasso$coefficientsSelect HFHS.clr_data &lt;- HFHS.x[ ,HFHS.results_clrlasso$varSelect] HFHS.clr.plotloadings &lt;- plotcoefficients(coef = HFHS.clr_coef, data = HFHS.clr_data, Y = HFHS.y, title = &#39;Coefficients of clr-lasso on HFHS-Day1 data&#39;, OTU = T, taxa = HFHS.taxonomy) Figure 5.13: The plotLoadings of selected variables with CLR-lasso. 5.2.4 Trajectory plots TRAJ_plot(selectVar_coef_method1 = HFHS.coda_coef, selectVar_coef_method2 = HFHS.clr_coef, selectMethods = c(&#39;CoDA-lasso&#39;, &#39;CLR-lasso&#39;), OTU = T, taxa = HFHS.taxonomy) Figure 5.14: Trajectory plots of selected variables with both CoDA-lasso and CLR-lasso in HFHS-Day1 data. In Figure 5.14, top four OTUs selected with CLR-lasso are also selected as top OTUs from CoDA-lasso but with different order. The other OTUs are either selected by CoDA-lasso or CLR-lasso (except OTU 462764: Ruminococcus). 5.2.5 GraPhlAn As we also have the taxonomic information of HFHS-Day1 data, we use GraPhlAn to visualise the taxonomic information of the selected OTUs. GraPhlAn is a software tool for producing high-quality circular representations of taxonomic and phylogenetic trees (https://huttenhower.sph.harvard.edu/graphlan). It is coded in Python. We first remove empty taxa (e.g. species) and aggregate all these selected variables into a list. Then we use function graphlan_annot_generation() to generate the input files that graphlan python codes require. In the save_folder, there are two existing files: annot_0.txt and graphlan_all.sh. After we generate our input files taxa.txt and annot_all.txt, we only need to run the graphlan_all.sh in the bash command line to generate the plot. # remove empty columns HFHS.tax_codalasso &lt;- HFHS.tax_codalasso[,-7] HFHS.tax_clrlasso &lt;- HFHS.tax_clrlasso[,-7] HFHS.tax_selbal &lt;- HFHS.tax_selbal[,-7] HFHS.select.tax &lt;- list(CoDA_lasso = HFHS.tax_codalasso, CLR_lasso = HFHS.tax_clrlasso, selbal = HFHS.tax_selbal) graphlan_annot_generation(taxa_list = HFHS.select.tax, save_folder = &#39;/Users/yiwenw5/Documents/GitHub/Methods_comparison/Methods_comparison/graphlan&#39;) Figure 5.15: GraPhlAn of selected taxa from different methods in HFHS-Day1 data. In Figure 5.15, the inner circle is a taxonomic tree of selected OTUs. The outside circles indicate different selection methods. If a proportion of a circle is coloured, it means that the corresponding OTU is selected by the method labeled on the circle. If the bottom nodes are coloured in gray, it indicates the OTUs are only selected by one method. References "],
["references.html", "References", " References "]
]
